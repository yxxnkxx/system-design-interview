# 8장 URL 단축기 설계

## 요구사항
- URL 단축
- URL 리디렉션
- 높은 가용성, 규모 확장성, 장애 감내

### 개략적 추정
- 쓰기 연산: 매일 1억 개의 단축 URL 생성
- 초당 쓰기 연산: 1160
- 읽기 연산: 10:1일때 초당 11,600
- 10년간 운영 시 3650억개의 단축 URL 보관
- 축약 전 URL 평균 길이: 100 -> 10년 36.5TB

## 개략 설계

### API 엔드포인트

1. URL 단축

`POST /api/v1/data/shorten`
- 인자: `longUrl: string`
- 반환: 단축 URL

2. URL 리디렉션

`GET /api/v1/data/{shortUrl}`
- 반환: 원본 URL로 리디렉션

리디렉션 응답
- 301 Moved Permanently: URL이 영구적으로 이동됨, 브라우저가 응답 캐시 후 이후 요청 시 캐시된 응답 사용
- 302 Found: URL이 일시적으로 이동됨, 브라우저가 캐시하지 않음

### URL 단축

해시 테이블 사용

해시 함수 
- URL에 따라 다른 해시 값 반환
- 기존 URL로 복원 가능

## 상세 설계

### 데이터 모델

데이터베이스에 저장

### 해시 함수

#### 해시값 길이

[0-9, a-z, A-Z] 62개 문자 사용 -> hashValue의 길이 = 62^n >= 36.5TB

-> n = 7

#### 해시 후 충돌 해소
알려진 해시 함수: MD5, SHA-1, CRC32

-> 해시 값이 길어짐

해결
- 해시 값에서 처음 7자리 사용
- 충돌 발생 시 사전에 정한 문자열을 해시값에 덧붙임

-> 오버헤드 발생

#### base-62 변환

- 62진법 사용
- 10진수를 62진수로 변환

**두 접근법 비교**

- 해시 후 충돌 해소
  - 단축 URL 길이 고정
  - 유일성이 보장되는 ID 생성기 필요 x
  - 충돌 가능 -> 해소 전략 필요
  - 다음에 쓸 수 있는 URL을 알아내는 것이 불가능
- base-62 변환
  - 단축 URL 길이 가변
  - 유일성이 보장되는 ID 생성기 필요
  - 충돌 불가
  - 다음에 쓸 수 있는 URL을 알아내는 것이 가능 -> 보안 문제 소지

### URL 단축기
1. 입력
2. 데이터베이스 확인
3. 값이 있다면 반환
4. 없는 경우 ID 생성
5. 62진법 변환 -> 단축 URL 생성
6. 데이터베이스에 저장
7. 단축 URL 반환

### URL 리디렉션

1. 단축 URL 클릭
2. 로드밸런서가 요청을 받아 서버로 전달
3. 캐시에 있는 경우 캐시된 응답 반환
4. 데이터베이스에서 원본 URL 찾기

